
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Vertical-Averaged Simulation: C-Acceleration on Large Model</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-02-08"><meta name="DC.source" content="runSlopingAquiferBig.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>Vertical-Averaged Simulation: C-Acceleration on Large Model</h1><!--introduction--><p>In this example we consider a synthetic sloping aquifier that has a significant variation in the top-surface morphology.</p><p>We demonstrate the use of C/C++-accelerated MATLAB, using the function mtransportVE to replace explicitTransportVE. Using mtransportVE requires that you have built the solver in the VEmex directory.</p><p>In addition, the routine makeIGEMSmodel that sets up the data model may use the following C-accelerated MATLAB routines</p><div><ul><li>processgrid (replaces processGRDECL)</li><li>mcomputegeometry (replaces computeGeometry)</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Write header</a></li><li><a href="#2">Construct stratigraphic, petrophysical, and VE models</a></li><li><a href="#3">Set time and fluid parameters</a></li><li><a href="#4">Set well and boundary conditions</a></li><li><a href="#5">Prepare simulations</a></li><li><a href="#6">Prepare plotting</a></li><li><a href="#7">Main loop</a></li></ul></div><h2>Write header<a name="1"></a></h2><pre class="codeinput">clc;
disp(<span class="string">'================================================================'</span>);
disp(<span class="string">'   Vertical averaging applied to a large model'</span>);
disp(<span class="string">'   using C++ accelleration in the transport solver'</span>);
disp(<span class="string">'================================================================'</span>);
disp(<span class="string">' '</span>);
</pre><pre class="codeoutput">================================================================
   Vertical averaging applied to a large model
   using C++ accelleration in the transport solver
================================================================
 
</pre><h2>Construct stratigraphic, petrophysical, and VE models<a name="2"></a></h2><p>The 3D model consists of a grid (G) and petrophysical parameters (rock). The VE model consists of a top-surface grid (Gt), petrophysical data (rock2D), and indices to the boundarcy cells where we will supply pressure boundary conditions. Called with a true flag, the routine will use C-accelerated MATLAB routines to process the data input and compute geometry. Once the models are created, they are stored in a data file for faster access at a later time.</p><pre class="codeinput">[G, Gt, rock, rock2D, bcIxVE] = makeSlopingAquiferBig(true);
</pre><pre class="codeoutput"> -&gt; Reading slopingAquiferBig.mat
 -&gt; Reading failed, constructing grid models
    Reading IGEMS.GRDECL
 -&gt; Processing grid
 -&gt; Constructing top-surface grid
 -&gt; Writing slopingAquiferBig.mat
</pre><h2>Set time and fluid parameters<a name="3"></a></h2><p>Inject CO2 for 150 years and study subsequent migration until 750 years after injection started. The fluid data are chosen so that they are resonable at p = 300 bar</p><pre class="codeinput">gravity <span class="string">on</span>
T          = 750*year();
stopInject = 150*year();
dT         = 2*year();
dTplot     = 2*dT;
fluidVE    = initVEFluidHForm(Gt, <span class="string">'mu'</span> , [0.056641 0.30860] .* centi*poise, <span class="keyword">...</span>
                         <span class="string">'rho'</span>, [686.54 975.86] .* kilogram/meter^3, <span class="keyword">...</span>
                        <span class="string">'sr'</span>, 0.2, <span class="string">'sw'</span>, 0.1, <span class="string">'kwm'</span>, [0.2142 0.85]);
</pre><h2>Set well and boundary conditions<a name="4"></a></h2><p>We use one well placed down the flank of the model, perforated in the bottom layer. Injection rate is 2.8e4 m^3/day of supercritical CO2. Hydrostatic boundary conditions are specified on all outer boundaries.</p><pre class="codeinput">disp(<span class="string">' -&gt; Setting well and boundary conditions'</span>);

<span class="comment">% Set well in 3D model</span>
wellIx = [G.cartDims(1:2)/5, G.cartDims([3 3])];
rate   = 2.8e4*meter^3/day;
W      = verticalWell([], G, rock, wellIx(1), wellIx(2), <span class="keyword">...</span>
                      wellIx(3):wellIx(4), <span class="string">'Type'</span>, <span class="string">'rate'</span>, <span class="string">'Val'</span>, rate, <span class="keyword">...</span>
                      <span class="string">'Radius'</span>, 0.1, <span class="string">'comp_i'</span>, [1,0], <span class="string">'name'</span>, <span class="string">'I'</span>);

<span class="comment">% Well in 2D model</span>
WVE = convertwellsVE(W, G, Gt, rock2D);

<span class="comment">% BC in 2D model</span>
bcVE   = addBC([], bcIxVE, <span class="string">'pressure'</span>, <span class="keyword">...</span>
            Gt.faces.z(bcIxVE)*fluidVE.rho(2)*norm(gravity));
bcVE   = rmfield(bcVE,<span class="string">'sat'</span>);
bcVE.h = zeros(size(bcVE.face));
</pre><pre class="codeoutput"> -&gt; Setting well and boundary conditions
</pre><h2>Prepare simulations<a name="5"></a></h2><p>Compute inner products and instantiate solution structure</p><pre class="codeinput">disp(<span class="string">' -&gt; Initialising solvers'</span>);
SVE = computeMimeticIPVE(Gt, rock2D, <span class="string">'Innerproduct'</span>,<span class="string">'ip_simple'</span>);
preComp = initTransportVE(Gt, rock2D);
sol = initResSolVE(Gt, 0, 0);
sol.wellSol = initWellSol(W, 300*barsa());
sol.s = height2Sat(sol, Gt, fluidVE);

<span class="comment">% Select transport solver</span>
<span class="comment">% Use C++ acceleration if it exists - NB: requires the VEmex module</span>
<span class="comment">% Notice that the two solvers determine the time steps differently and</span>
<span class="comment">% may therefore give slightly different answers.</span>
<span class="keyword">try</span>
   mtransportVE();
   cpp_accel = true;
<span class="keyword">catch</span> me
   d = fileparts(mfilename(<span class="string">'fullpath'</span>));
   disp(<span class="string">'mex-file for C++ acceleration not found'</span>);
   disp([<span class="string">'See '</span>, fullfile(VEROOTDIR,<span class="string">'VEmex'</span>,<span class="string">'README'</span>), <span class="string">' for building instructions'</span>]);
   disp(<span class="string">'Using matlab ve-transport'</span>);
   cpp_accel = false;
<span class="keyword">end</span>

<span class="comment">% Find trapping structure in grid. Used for calculation of trapped volumes</span>
ts=findTrappingStructure(Gt);
</pre><pre class="codeoutput"> -&gt; Initialising solvers
Trap level 1: 643 traps identified
Trap level 2: 103 traps identified
Trap level 3: 17 traps identified
Trap level 4: 4 traps identified
Trap level 5: 1 traps identified
</pre><h2>Prepare plotting<a name="6"></a></h2><p>We will make a composite plot that consists of several parts: a 3D plot of the plume, a pie chart of trapped versus free volume, a plane view of the plume from above, and two cross-sections in the x/y directions through the well</p><pre class="codeinput">opts = {<span class="string">'slice'</span>, wellIx, <span class="string">'Saxis'</span>, [0 1-fluidVE.sw], <span class="keyword">...</span>
   <span class="string">'maxH'</span>, 200, <span class="string">'Wadd'</span>, 1000};
plotPanelVE(G, Gt, W, sol, 0.0, [0 0 1], opts{:});
</pre><img vspace="5" hspace="5" src="runSlopingAquiferBig_01.png" alt=""> <h2>Main loop<a name="7"></a></h2><p>Run the simulation using a sequential splitting with pressure and transport computed in separate steps. The transport solver is formulated with the height of the CO2 plume as the primary unknown and the relative height (or saturation) must therefore be reconstructed.</p><pre class="codeinput">t = 0;
totVol = 0.0;
fprintf(1,<span class="string">'\nSimulating %d years of injection'</span>, convertTo(stopInject,year));
fprintf(1,<span class="string">' and %d years of migration\n'</span>, convertTo(T-stopInject,year));
fprintf(1,<span class="string">'Time: %4d years'</span>, convertTo(t,year));
tic
<span class="keyword">while</span> t&lt;T
   <span class="comment">% Advance solution: compute pressure and then transport</span>
   sol = solveIncompFlowVE(sol, Gt, SVE, rock, fluidVE, <span class="keyword">...</span>
      <span class="string">'bc'</span>, bcVE, <span class="string">'wells'</span>, WVE);

   <span class="keyword">if</span> cpp_accel
      [sol.h, sol.h_max] = mtransportVE(sol, Gt, dT, rock, <span class="keyword">...</span>
                                          fluidVE, <span class="string">'bc'</span>, bcVE, <span class="string">'wells'</span>, WVE, <span class="keyword">...</span>
                                          <span class="string">'gravity'</span>, norm(gravity));
   <span class="keyword">else</span>
      sol = explicitTransportVE(sol, Gt, dT, rock, fluidVE, <span class="keyword">...</span>
                               <span class="string">'bc'</span>, bcVE, <span class="string">'wells'</span>, WVE,    <span class="keyword">...</span>
                               <span class="string">'preComp'</span>, preComp,          <span class="keyword">...</span>
                               <span class="string">'intVert'</span>, false);
   <span class="keyword">end</span>

   <span class="comment">% Reconstruct 'saturation' defined as s=h/H, where h is the height of</span>
   <span class="comment">% the CO2 plume and H is the total height of the formation</span>
   sol.s = height2Sat(sol, Gt, fluidVE);
   assert( max(sol.s(:,1))&lt;1+eps &amp;&amp; min(sol.s(:,1))&gt;-eps );
   t = t + dT;

   <span class="comment">% Compute total injected, trapped and free volumes of CO2</span>
   <span class="keyword">if</span> ~isempty(WVE)
      totVol = totVol + WVE.val*dT;
   <span class="keyword">end</span>
   vol = volumesVE(Gt, sol, rock2D, fluidVE, ts);

   <span class="comment">% Check if we are to stop injecting. If so, increase the time step.</span>
   <span class="keyword">if</span> t&gt;= stopInject
      WVE  = []; dT = 10*year(); dTplot = dT;
   <span class="keyword">end</span>

   <span class="comment">% Plotting</span>
   fprintf(1,<span class="string">'\b\b\b\b\b\b\b\b\b\b%4d years'</span>, convertTo(t,year));
   <span class="keyword">if</span> mod(t,dTplot)~= 0 &amp;&amp; t&lt;T,
      <span class="keyword">continue</span>
   <span class="keyword">else</span>
      plotPanelVE(G, Gt, W, sol, t, [vol totVol], opts{:});
      drawnow
   <span class="keyword">end</span>
<span class="keyword">end</span>
fprintf(1,<span class="string">'\n\n'</span>);

<span class="comment">% delete C++ simulator</span>
<span class="keyword">if</span> cpp_accel, mtransportVE(); <span class="keyword">end</span>
etime = toc;
disp([<span class="string">'Elapsed simulation time: '</span>, num2str(etime), <span class="string">' seconds.'</span>]);
</pre><pre class="codeoutput">
Simulating 150 years of injection and 600 years of migration
Time:  750 years

Elapsed simulation time: 246.6088 seconds.
</pre><img vspace="5" hspace="5" src="runSlopingAquiferBig_02.png" alt=""> <p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
%% Vertical-Averaged Simulation: C-Acceleration on Large Model
% In this example we consider a synthetic sloping aquifier that has a
% significant variation in the top-surface morphology.
%
% We demonstrate the use of C/C++-accelerated MATLAB, using the function
% mtransportVE to replace explicitTransportVE. Using mtransportVE requires
% that you have built the solver in the VEmex directory.
%
% In addition, the routine makeIGEMSmodel that sets up the data model may
% use the following C-accelerated MATLAB routines
%
% * processgrid (replaces processGRDECL)
% * mcomputegeometry (replaces computeGeometry)

%% Write header
clc;
disp('================================================================');
disp('   Vertical averaging applied to a large model');
disp('   using C++ accelleration in the transport solver');
disp('================================================================');
disp(' ');

%% Construct stratigraphic, petrophysical, and VE models
% The 3D model consists of a grid (G) and petrophysical parameters (rock).
% The VE model consists of a top-surface grid (Gt), petrophysical data
% (rock2D), and indices to the boundarcy cells where we will supply
% pressure boundary conditions. Called with a true flag, the routine will
% use C-accelerated MATLAB routines to process the data input and compute
% geometry. Once the models are created, they are stored in a data file for
% faster access at a later time.
[G, Gt, rock, rock2D, bcIxVE] = makeSlopingAquiferBig(true);

%% Set time and fluid parameters
% Inject CO2 for 150 years and study subsequent migration until 750 years
% after injection started. The fluid data are chosen so that they are
% resonable at p = 300 bar
gravity on
T          = 750*year();
stopInject = 150*year();
dT         = 2*year();
dTplot     = 2*dT;
fluidVE    = initVEFluidHForm(Gt, 'mu' , [0.056641 0.30860] .* centi*poise, ...
                         'rho', [686.54 975.86] .* kilogram/meter^3, ...
                        'sr', 0.2, 'sw', 0.1, 'kwm', [0.2142 0.85]);

%% Set well and boundary conditions
% We use one well placed down the flank of the model, perforated in the
% bottom layer. Injection rate is 2.8e4 m^3/day of supercritical CO2.
% Hydrostatic boundary conditions are specified on all outer boundaries.
disp(' -> Setting well and boundary conditions');

% Set well in 3D model
wellIx = [G.cartDims(1:2)/5, G.cartDims([3 3])];
rate   = 2.8e4*meter^3/day;
W      = verticalWell([], G, rock, wellIx(1), wellIx(2), ...
                      wellIx(3):wellIx(4), 'Type', 'rate', 'Val', rate, ...
                      'Radius', 0.1, 'comp_i', [1,0], 'name', 'I');

% Well in 2D model
WVE = convertwellsVE(W, G, Gt, rock2D);

% BC in 2D model
bcVE   = addBC([], bcIxVE, 'pressure', ...
            Gt.faces.z(bcIxVE)*fluidVE.rho(2)*norm(gravity));
bcVE   = rmfield(bcVE,'sat');
bcVE.h = zeros(size(bcVE.face));


%% Prepare simulations
% Compute inner products and instantiate solution structure
disp(' -> Initialising solvers');
SVE = computeMimeticIPVE(Gt, rock2D, 'Innerproduct','ip_simple');
preComp = initTransportVE(Gt, rock2D);
sol = initResSolVE(Gt, 0, 0);
sol.wellSol = initWellSol(W, 300*barsa());
sol.s = height2Sat(sol, Gt, fluidVE);

% Select transport solver
% Use C++ acceleration if it exists - NB: requires the VEmex module
% Notice that the two solvers determine the time steps differently and
% may therefore give slightly different answers.
try
   mtransportVE();
   cpp_accel = true;
catch me
   d = fileparts(mfilename('fullpath'));
   disp('mex-file for C++ acceleration not found');
   disp(['See ', fullfile(VEROOTDIR,'VEmex','README'), ' for building instructions']);
   disp('Using matlab ve-transport');
   cpp_accel = false;
end

% Find trapping structure in grid. Used for calculation of trapped volumes
ts=findTrappingStructure(Gt);

%% Prepare plotting
% We will make a composite plot that consists of several parts: a 3D plot
% of the plume, a pie chart of trapped versus free volume, a plane view of
% the plume from above, and two cross-sections in the x/y directions
% through the well
opts = {'slice', wellIx, 'Saxis', [0 1-fluidVE.sw], ...
   'maxH', 200, 'Wadd', 1000};
plotPanelVE(G, Gt, W, sol, 0.0, [0 0 1], opts{:});

%% Main loop
% Run the simulation using a sequential splitting with pressure and
% transport computed in separate steps. The transport solver is formulated
% with the height of the CO2 plume as the primary unknown and the relative
% height (or saturation) must therefore be reconstructed.
t = 0;
totVol = 0.0;
fprintf(1,'\nSimulating %d years of injection', convertTo(stopInject,year));
fprintf(1,' and %d years of migration\n', convertTo(T-stopInject,year));
fprintf(1,'Time: %4d years', convertTo(t,year));
tic
while t<T
   % Advance solution: compute pressure and then transport
   sol = solveIncompFlowVE(sol, Gt, SVE, rock, fluidVE, ...
      'bc', bcVE, 'wells', WVE);

   if cpp_accel
      [sol.h, sol.h_max] = mtransportVE(sol, Gt, dT, rock, ...
                                          fluidVE, 'bc', bcVE, 'wells', WVE, ...
                                          'gravity', norm(gravity));
   else
      sol = explicitTransportVE(sol, Gt, dT, rock, fluidVE, ...
                               'bc', bcVE, 'wells', WVE,    ...
                               'preComp', preComp,          ...
                               'intVert', false);
   end
   
   % Reconstruct 'saturation' defined as s=h/H, where h is the height of
   % the CO2 plume and H is the total height of the formation
   sol.s = height2Sat(sol, Gt, fluidVE);
   assert( max(sol.s(:,1))<1+eps && min(sol.s(:,1))>-eps );
   t = t + dT;

   % Compute total injected, trapped and free volumes of CO2
   if ~isempty(WVE)
      totVol = totVol + WVE.val*dT;
   end
   vol = volumesVE(Gt, sol, rock2D, fluidVE, ts);

   % Check if we are to stop injecting. If so, increase the time step.
   if t>= stopInject
      WVE  = []; dT = 10*year(); dTplot = dT;
   end

   % Plotting
   fprintf(1,'\b\b\b\b\b\b\b\b\b\b%4d years', convertTo(t,year));
   if mod(t,dTplot)~= 0 && t<T,
      continue
   else
      plotPanelVE(G, Gt, W, sol, t, [vol totVol], opts{:});
      drawnow
   end
end
fprintf(1,'\n\n');

% delete C++ simulator
if cpp_accel, mtransportVE(); end
etime = toc;
disp(['Elapsed simulation time: ', num2str(etime), ' seconds.']);

displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>
