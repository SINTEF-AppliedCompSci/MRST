function mesh = simpleExtrudedFluidFlowerMesh(resolution, varargin)
    opt = struct( ...
        'depth', '1km', ...
        'save', true, ...
        'force_regen', false, ...
        'plot', false ...
        );
    opt = merge_options(opt, varargin{:});
    % Create 3D extruded mesh
    % First, we create a vertical cross section with a single fault and folded
    % stratigraphy. Second, we extrude the cross section to have a 3D 
    % computational domain with the correct dimensions (e.g. the dimensions 
    % of the experimental sandbox).
    %
    % Requirements: upr (https://github.com/rbe051/UPR)
    % ------------------------------------------------------------------------
    
    % Cleanup
    % clear, close all
    mrstModule add upr
    
    % grid depth
    depth = opt.depth; % '1km' or 'surface' (fluidflower)
    
    % Plotting functionality
    fig2D = @() figure('Position', [0,0,800,500]);
    fig3D = @() figure('Position', [0,0,1300, 650]);
    alpha = 0.6;
    cmap  = jet*alpha + (1-alpha);
    setAxProps = @(ax) set(ax, 'View'              , [50, 20]         , ...
                               'PlotBoxAspectRatio', [4.40, 1.86, 1.00], ...
                               'Projection'        , 'Perspective'     , ...
                               'Box'               , 'on'              , ...
                               'ColorMap'          , cmap              );
    
    
    % Load data
    % We start by loading a data structure that contains points describing the
    % outline, faults, and well positions (see simpleExtrudedMesh_datapoints.m)
    meshpt  = simpleExtrudedMesh_datapoints();
    
    % Scale to 1m, and convert depth (depth is positive in MRST)
    xmx = max(meshpt.boundary(:,1));
    meshpt.boundary(:,1) = meshpt.boundary(:,1)/xmx;
    meshpt.boundary(:,2) = meshpt.boundary(:,2)/-xmx;
    for n=1:length(meshpt.lines)
        if n <= 2
            meshpt.wells{n}(:, 1) = meshpt.wells{n}(:, 1)/xmx; 
            meshpt.wells{n}(:, 2) = meshpt.wells{n}(:, 2)/-xmx; 
        end
        meshpt.lines{n}(:, 1) = meshpt.lines{n}(:, 1)/xmx; 
        meshpt.lines{n}(:, 2) = meshpt.lines{n}(:, 2)/-xmx; 
    end
    
    % plot
    if opt.plot
        fig2D(), hold on
        plot(meshpt.boundary(:,1), meshpt.boundary(:,2), 'k')
        plotLinePath(meshpt.lines(4:end), 'b');
        plotLinePath(meshpt.lines(1:3), 'r');
        plotLinePath(meshpt.wells, '.g', 'markerSize', 20);
        box on, axis equal tight, view([0, -90])
        xlabel('x [m]'); ylabel('z = depth [m]')
    end
    
    
    % Generate 2D PEBI grid
    % We construct a 2D composite PEBI grid from the datapoints using the upr
    % module of MRST and the constraints imposed by the stratigraphy and fault.
    % The parameter nc controls the number of cells, for an approximation you
    % can do number of cells = 3/cellSize(1) * 2/cellSize(2)
    % 
    if strcmp(resolution, 'coarse')
        cellSize = [1 1]*1e-2; % cm to m
        fcf      = 0.5;
    elseif strcmp(resolution, 'medium')
        cellSize = [0.5 0.5]*1e-2; % cm to m
        fcf      = 1;
    elseif strcmp(resolution, 'fine')   % about 60k cells
        disp('Generating fine mesh. This could take several minutes.')
        cellSize = [0.25 0.25]*1e-2; % cm to m
        fcf      = 1;
    end
    if strcmp(depth, '1km')
        nm = '_depth1km';
    else
        nm = '';
    end
    filename = fullfile(pathToGeneratedMeshesCO2labMIT(), ['simpleExtrudedG_cellSize' ...                      
                            num2str(cellSize(1)*1e2) 'cm' nm '.mat']);
    if exist(filename, 'file') && ~opt.force_regen
        mesh = load(filename);
    else
        tic
        L   = max(abs(meshpt.boundary));
        G2D = compositePebiGrid2D(cellSize, [L(1) L(2)], ...
              'polybdr', meshpt.boundary, ...           % Outline
              'faceConstraints', meshpt.lines, ...      % Fault lines
              'FCFactor'       , fcf          , ...     % Relative size of fault-line cells
              'cellConstraints', meshpt.wells , ...     % Well coordinates
              'interpolateCC'  , false, ...
              'CCFactor'       , 1         ,  ...       % Relative size of well cells
              'interpolateFC'  , true);
        G2D = removeShortEdges(G2D, 5e-05); % The grid may contain very short edges.
        toc
                                        
        
        % Plot 2D grid
        % Well cells are identified with G.cells.tag = true. We will need the well
        % number later, so we find and store these.
        wellNo2D                = nan(G2D.cells.num,1);
        wellNo2D(G2D.cells.tag) = 1:nnz(G2D.cells.tag);
        if opt.plot
            fig2D(), plotGrid(G2D); axis equal tight, box on                 % Grid
            plotFaces(G2D, G2D.faces.tag, 'edgeColor', 'b', 'lineWidth', 2); % Lines
            plotGrid(G2D, G2D.cells.tag , 'faceColor', 'r');                 % Wells
            view([0 -90])
        end
        
        
        % Find regions
        % The lines divide the reservoir into 9 distinct regions. We identify
        % these using functionality from the coarsegrid module
        mrstModule add coarsegrid
        p = ones(G2D.cells.num,1);
        p = processPartition(G2D, p, find(G2D.faces.tag));
        
        % Visualize regions
        if opt.plot
            for n=1:max(p)
               plotCellData(G2D, n*ones(sum(p==n), 1), p==n)
            end
            view([0 -90])
            colorbar
        end
        
        
        % Extrude (2.5D)
        % We construct a volumetric reservoir model by extruding the 2D grid. The
        % function makeLayeredGrid uses a 2D grid [x, y] and extrudes to the z
        % dimension (depth). Since we have x and z, we will reorganize our grid's
        % dimensions so that we get the correct z.
        
        % Make layered grid
        nLayers = 1;                        % Number of layers
        layerThickness = 1e-2*1;            % 1 cm thick
        G = makeLayeredGrid(G2D, nLayers);  % by default 1m thick
        G.nodes.coords(G.nodes.coords(:, 3) == 1, 3) = layerThickness;    % update thick
        G.nodes.coords = G.nodes.coords(:, [3 1 2]); % x -> y, y -> z, new dim = x
        if strcmp(depth, '1km')
            G.nodes.coords(:,3) = G.nodes.coords(:,3) + 1000;
        end
        G = computeGeometry(G);             % compute cell centroids, etc
        
        % Pass cell tags to the grid for later convenience
        G.cells.tag = repmat(G2D.cells.tag, nLayers, 1); % hz well cells (all layers)
        
        % Save IDs of wells, layer(s) and compartments 
        wellNo       = repmat(wellNo2D, nLayers, 1);
        layerID      = reshape(repmat(1:nLayers, G2D.cells.num, 1), [], 1);
        compartID    = repmat(p,nLayers,1);
        
        
        % Save data
        if opt.save
            save(filename, 'G', 'G2D', 'p', 'compartID', 'wellNo', 'layerID')
        end
        mesh = struct('G', G, 'G2D', G2D, 'p', p, 'compartID', compartID, 'wellNo', wellNo, 'layerID', layerID);
        % Plot the resulting layered grid
        % Here we use darker colors for suggested seal/caprock layers and lighter 
        % colors for reservoir layers. The fault here is colored as a conducive
        % (high permeability) structure.
        if opt.plot
            fig3D();
            if strcmp(resolution, 'coarse')
                lyrs = {[1 8], [2 9], [4 7], 3, 5, 6}; % to be modified on a grid to grid basis
            elseif strcmp(resolution, 'medium')
                lyrs = {[1 8], [2 9], [4 7], 3, 5, 6};
            elseif strcmp(resolution, 'fine')
                lyrs = {[1 8], [2 9], [4 7], 3, 5, 6};
            end
            colr = [3, 8, 7, 4, 1, 6];
            for n=1:numel(lyrs)
                plotCellData(G, colr(n)*ones(sum(ismember(p, lyrs{n})), 1), ...
                             ismember(p, lyrs{n}), 'edgealpha', 0.2)
            end
            outlineCoarseGrid(G, compartID,'EdgeColor','w','LineWidth',2);
            setAxProps(gca), %camlight();
            colormap(copper); c = colorbar; set(c, 'YTick', sort(colr));
            axis equal 
            xlabel('x [m]'), ylabel('y [m]'), zlabel('z [m]')
            %ylim([0 1]), zlim([0 1])
        end
    end
end

function stratiPoints = simpleExtrudedMesh_datapoints()
    % Make datapoints for mesh conforming to boundary, fault, folded layers
    % Boundary
    stratiPoints = struct('boundary', [], 'lines', [], 'wells', []);
    stratiPoints.boundary = [0, 0; ...
                             0.25, -0.02; ...
                             0.5, -0.03; ...
                             0.75, -0.04; ...
                             1, -0.05; ...
                             1.1, -0.06; ...
                             1.2, -0.07; ...
                             1.25, -0.075; ...
                             1.3, -0.081; ...
                             1.35, -0.083; ...
                             1.4, -0.085; ...
                             1.5, -0.086; ...
                             1.75, -0.085; ...
                             1.9, -0.075; ...
                             2, -0.063; ...
                             2.25, -0.042; ...
                             2.5, -0.021; ...
                             2.75, -0.01; ...
                             3, 0; ...
                             3, -2; ...
                             0, -2; ...
                             0, 0];
                         
    % Wells (to have cells with correct centroids)
    stratiPoints.wells{1} = [1.57, -1.75];
    stratiPoints.wells{2} = [1.605, -1.05];
    
    % Fault lines (There is 1 fault-like structure, but we need two lines to 
    %              define its thickness)
    stratiPoints.lines{1} = [1.5, -1.8; ...
                             1.55, -1.65; ...
                             1.6, -1.45; ...
                             1.65, -1.2; ...
                             1.68, -0.9; ...
                             1.76, -0.4];
                              
    stratiPoints.lines{2} = [1.54, -1.8; ...
                             1.61, -1.51; ...
                             1.65, -1.3; ...
                             1.7, -1; ...
                             1.72, -0.75; ...
                             1.78, -0.4];
    
    stratiPoints.lines{3} = [1.76, -0.4; ...
                             1.78, -0.4]; % fault closure
    
    % Layer lines (top to bottom)
    % Bottom horizon
    stratiPoints.lines{4} = [0, -1.8; ...
                             0.25, -1.8; ...
                             0.5, -1.79; ...
                             0.75, -1.78; ...
                             1, -1.775; ...
                             1.1, -1.77; ...
                             1.2, -1.765; ...
                             1.3, -1.77; ...
                             1.4, -1.78; ...
                             1.5, -1.8; ...
                             1.54, -1.8; ...
                             1.9, -1.82; ...
                             2, -1.81; ...
                             2.25, -1.8; ...
                             2.5, -1.79; ...
                             2.75, -1.78; ...
                             3, -1.78];
    % Hangingwall             
    stratiPoints.lines{5} = [0, -1.525; ...
                             0.2, -1.52; ...
                             0.4, -1.515; ...
                             0.6, -1.51; ...
                             0.8, -1.5; ...
                             0.9, -1.505; ...
                             1, -1.52; ...
                             1.2, -1.55; ...
                             1.4, -1.61; ...
                             1.55, -1.65];
    
    stratiPoints.lines{6} = [0, -1.078; ...
                             0.2, -1.075; ...
                             0.4, -1.07; ...
                             0.6, -1.065; ...
                             0.8, -1.06; ...
                             0.9, -1.05; ...
                             1, -1.045; ...
                             1.2, -1.05; ...
                             1.3, -1.06; ...
                             1.4, -1.08; ...
                             1.5, -1.11; ...
                             1.6, -1.16; ...
                             1.65, -1.2];
                         
    stratiPoints.lines{7} = [0, -0.8; ...
                             0.2, -0.8; ...
                             0.4, -0.8; ...
                             0.6, -0.795; ...
                             0.8, -0.79; ...
                             0.9, -0.78; ...
                             1, -0.77; ...
                             1.1, -0.76; ...
                             1.2, -0.75; ...
                             1.3, -0.76; ...
                             1.4, -0.78; ...
                             1.5, -0.81; ...
                             1.6, -0.85; ...
                             1.68, -0.9];                 
    % Footwall
    stratiPoints.lines{8} = [1.61, -1.51; ...
                             1.7, -1.5; ...
                             1.8, -1.48; ...
                             1.9, -1.465; ...
                             2, -1.46; ...
                             2.2, -1.46; ...
                             2.4, -1.47; ...
                             2.6, -1.487; ...
                             2.8, -1.504; ...
                             2.9, -1.515; ...
                             3, -1.53];
    
    stratiPoints.lines{9} = [1.7, -1; ...
                             1.8, -0.99; ...
                             1.9, -0.97; ...
                             2, -0.965; ...
                             2.1, -0.97; ...
                             2.2, -0.975; ...
                             2.4, -0.982; ...
                             2.6, -0.991; ...
                             2.8, -1.02; ...
                             3, -1.06];
                         
    stratiPoints.lines{10} = [1.72, -0.75; ...
                              1.8, -0.745; ...
                              1.9, -0.735; ...
                              2, -0.72; ...
                              2.1, -0.72; ...
                              2.2, -0.725; ...
                              2.4, -0.732; ...
                              2.6, -0.748; ...
                              2.8, -0.77; ...
                              3, -0.795];
                          
    % Save data
    % Run the following command to see directory where datapoints will be saved
    % >> pwd 
    % save(out_path, 'stratiPoints');
end
