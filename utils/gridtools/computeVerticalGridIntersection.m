function polygons = computeVerticalGridIntersection(G, segments)
% Compute polygons generated by an intersection of a piecewise linear
% vertical surface and grid structure
%
% SYNOPSIS:
%   poly = computeVerticalGridIntersection(G, segments)
%
% DESCRIPTION:
%
%
% REQUIRED PARAMETERS:
%
%   G        - Grid structure with geometry and preferably 'bbox'-field included
%               for G.faces (see addBoundingBoxFields)
%
%   segemts  - x-y line segments (nx2) defining the piecewise linear intersection 
%              surface. If size(segments, 2) = 3, segments(:, 1:2) is used
%              
% 
% RETURNS:
%  polygons  - struct containing details of all traversed grid cells:
%              nodes    - matrix where row k contains indices to nodes (vertices)
%                         for polygon k
%              coords3D - node coordinates
%              coords2D - 2D node coordinates where first coordinate is
%                         along length of segmnents, and second is z-coordinate
%              cellIx   - index vector where entry k points to grid-cell
%                         being cut by k-th polygon. 
% EXAMPLE:
%  G    = addBoundingBoxFields(computeGeometry(cartGrid([20 20 10]))) 
%  poly = computeVerticalGridIntersection(G, 15*[sin((0:.1:2))', .5*cos(0:.1:2)']);
%  patch('Faces', poly.nodes, 'Vertices', poly.coords3D, 'FaceColor', 'y')
%  view(3)

%{
Copyright 2009-2021 SINTEF Digital, Mathematics & Cybernetics.

This file is part of The MATLAB Reservoir Simulation Toolbox (MRST).

MRST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MRST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MRST.  If not, see <http://www.gnu.org/licenses/>.
%}

if ~isfield(G.faces, 'bbox')
    G = addBoundingBoxFields(G);
end

segments  = segments(:, 1:2);
nseg = size(segments,1)-1;
% pick intial candidate subset of faces
if nseg > 1
    fix0 = getFacesCloseToSegment(G, segments);
else
    [fix0] = deal([]);
end

[p, t, fno] = deal(cell(1, nseg));
ts = 0;

cumlen = zeros(nseg+1, 1);
for k = 1:nseg
    curseg = segments([k, k+1],:);
    fix = getFacesCloseToSegment(G, curseg, 'faceIx', fix0);
    
    [p1, p2, faceNo] = getFaceSegments(G, fix);
    
    % current vertical plane through curseg n*x+d=0;
    v = diff(curseg);
    n = [-v(2), v(1), 0];
    d = curseg(1,:)*n(1:2)';
    [pcur, ix] = getPlaneIntersections(p1, p2, n, d, curseg);
    % also compute length along plane
    rp = bsxfun(@minus, pcur(:, 1:2), curseg(1,:));
    tcur = ts + sqrt(dot(rp, rp, 2));
    ts = ts + norm(v);
    cumlen(k+1) = ts;
    [p{k}, t{k}, fno{k}] = deal(pcur, tcur, faceNo(ix));
end
[p, t, fno] = deal(vertcat(p{:}), vertcat(t{:}), vertcat(fno{:}));
% extend to cells
cno  = G.faces.neighbors(fno,:);
[nz1, nz2] = deal(cno(:,1)>0, cno(:,2)>0);
[p, t, cno] = deal([p(nz1,:); p(nz2,:)], [t(nz1); t(nz2)], [cno(nz1,1); cno(nz2,2)]);

% reindex c 1:n
cix = unique(cno);
if cix(1) == 0
    cix = cix(2:end);
end
rix = sparse(G.cells.num, 1);
rix(cix) = (1:numel(cix));
cno_loc = full(rix(cno));
npnt = accumarray(cno_loc, ones(size(cno_loc)));

npol = numel(npnt);
% compute angle in (t, p(:,3)) -plane of points wrt face center
pp = [t, p(:,3)];
cent  = [accumarray(cno_loc, pp(:,1)), accumarray(cno_loc, pp(:,2))]./npnt;
rp    = pp - cent(cno_loc,:);
theta = atan2(rp(:,2), rp(:,1));
[~, order] = sortrows([cno_loc, theta]);
% each point now occurs twice, will come in pairs after sorting
% here we will loose some poly neighbour-info, redo if this is important
%order = order(1:2:end); 
%npnt = npnt/2;
[p, t, cno_loc] = deal(p(order,:), t(order), cno_loc(order));
cno = cix(cno_loc);

% make vertice info
maxp = max(npnt);
%unique(npnt)

cumc  = cumsum(npnt);
pos   = [1; cumc(1:end-1)+1];
nodes = zeros(npol, maxp);
cl    = (1:numel(cno))';
for k = 1:maxp
   nodes(:,k) =  cl(min(pos+k-1, cumc));
end

polygons = struct('nodes',           nodes, ...
                  'coords3D',            p, ... 
                  'coords2D',  [t, p(:,3)], ...
                  'cellIx',            cix, ...
                  'segments',          segments, ...
                  'cumlength',      cumlen);
end
% -------------------------------------------------------------------------
function [p1, p2, faceNo] = getFaceSegments(G, f)
[np1, np2] = deal(G.faces.nodePos(f), G.faces.nodePos(f+1));
faceNo = rldecode(f(:), np2-np1);

nodes = G.faces.nodes(mcolon(np1, np2-1));
nnode = np2-np1;
locpos = [1; cumsum(nnode)+1];
next   = (2:numel(nodes)+1) .';
next(locpos(2 : end) - 1) = locpos(1 : end-1);

% triangle vertices
p1 = G.nodes.coords(nodes,:);
p2 = G.nodes.coords(nodes(next),:);
end

function [p, ix] = getPlaneIntersections(p1, p2, n, d, seg)
v  = p2-p1;
vn = v*n';
ok = abs(vn) >0;
t  = nan(size(vn));
%t  = (p1*n'-d)./v*n';
t(ok) = -(p1(ok,:)*n'-d)./vn(ok);
ix = find(t>=0 & t <= 1);
p  = p1(ix,:) + bsxfun(@times, t(ix), v(ix,:));
% only those along segment
v = diff(seg);
s = (p(:,1:2)*v(1:2)' - seg(1,:)*v')/(v*v');
ix2 = s>=0 & s <=1;
[p, ix]  =deal(p(ix2, :), ix(ix2));
end
