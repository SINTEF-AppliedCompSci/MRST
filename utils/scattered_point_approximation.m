function splinefun = scattered_point_approximation(points, num_refinements, start_res, domain, start_with_zero_surf)
%
% Scattered data interpolation with multilevel B-splines
% 
% SYNOPSIS:
%   function splinefun = scattered_point_approximation(points, num_refinements, start_res, domain, start_with_zero_surf)
%
% DESCRIPTION:
% 
% This function implements an heuristic algorithm for creating approximating
% spline surfaces from scattered points, using a multilevel B-spline
% algorithm presented in the paper [10.1109/2945.620490] (Wolberg and Shin, 1997)
% 
% Contrary to the generate_trend_surface function, the algorithm employed
% here is entirely local (no global minimzation principle involved).  The
% multiple levels of spline refinement contribute in extending local
% information outwards.
% 
% PARAMETERS:
%   points               - scattered 3D points to approximate. Must be
%                          projectable to the (x, y) plane.
%   num_refinements      - How many levels to employ in the multilevel algorithm
%   start_res            - Number of patches (in x and y) at the highest level
%   domain               - [min_x, min_y, max_x, max_y] - specifies the total
%                          parameteric domain to consider
%   start_with_zero_surf - Set to true if highest level should be the zero
%                          surface (e.g. no approximation at this level)
%
% RETURNS:
%   splinefun - B-spline surface object generated by the algorithm from the
%               scattered points.
%
% EXAMPLE:
%
% SEE ALSO:
% generate_trend_surface, BivariateSplineFunction

%{
Copyright 2009-2022 SINTEF Digital, Mathematics & Cybernetics.

This file is part of The MATLAB Reservoir Simulation Toolbox (MRST).

MRST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MRST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MRST.  If not, see <http://www.gnu.org/licenses/>.
%}

   if ~exist('start_res', 'var')
      start_res = [1, 1]; % we start with one single patch 
   end
   
   if ~exist('start_with_zero_surf', 'var')
      start_with_zero_surf = false;
   end
      
   % compute domain from input points if it has not been explicitly provided
   if ~exist('domain', 'var') || isempty(domain)
      domain = [min(points(:,1:2)), max(points(:,1:2))]; % [umin, vmin, umax, vmax]
   end
   
   % rescaling points to fit into domain [0,1]x[0,1], which will be the working domain
   points(:,1:2) = (points(:,1:2) - domain(1:2)) ./ (domain(3:4) - domain(1:2));
   
   % first, carry out a least squares approximation at the lowest level (use high
   % stiffness to avoid funny behavior towards edges with little data)
   splinefun = BivariateSplineFunction([4,4], ...
                                  uniform_kvec([0,1], start_res(1)), ...
                                  uniform_kvec([0,1], start_res(2)));
   if ~start_with_zero_surf
      splinefun.approximate(points(:,1:2), points(:,3), 'none', 1e-4); 
   end
   
   % carry out MBA algorithm
   for i = 1:num_refinements
      splinefun = refine(splinefun);
      splinefun = apply_mba(splinefun, points);
   end

   % rescale knot vectors to represent original domain
   splinefun.knots_u = uniform_kvec(domain([1,3]), start_res(1) * 2^num_refinements);
   splinefun.knots_v = uniform_kvec(domain([2,4]), start_res(2) * 2^num_refinements);
   
end


function spl = apply_mba(spl, points)

   % computing residuals
   points(:,3) = points(:,3) - spl.evaluate(points(:,1:2));
   
   % computing location of each point in the grid of spline patches
   num_intervals = [spl.numIntervals(1), spl.numIntervals(2)];
   
   ij_pos = floor(points(:, 1:2) .* num_intervals);
   ij_pos(:,1) = min(ij_pos(:,1), num_intervals(1)-1); % remove edge case
   ij_pos(:,2) = min(ij_pos(:,2), num_intervals(2)-1); % remove edge case
   
   % computing local parameterization of each point
   points(:, 1:2) = points(:, 1:2) - ...
                    (ij_pos ./ [spl.numIntervals(1), spl.numIntervals(2)]);
   points(:, 1:2) = points(:, 1:2) .* num_intervals;
   
   % computing weights (tensor products)
   w = [compute_weights(points(:,1)), compute_weights(points(:,2))];
   wtmp = mat2cell(w', 8, ones(size(w, 1), 1));
   weights = cellfun(@(r) kron(r(5:8), r(1:4)), wtmp, 'uniformoutput', false);
   weights = cell2mat(weights);

   % accumulating point contributions
   nom = reshape(weights .* points(:,3)', [], 1);
   denom = reshape(repmat(sum(weights.^2), 16, 1), [], 1);
   
   phi = nom ./ denom;
   
   w2 = (weights(:)).^2;
   
   ixs = setup_cp_indices(ij_pos + 1, size(spl.coefs));

   w2_phi = w2 .* phi;
   
   tmp1 = accumarray(ixs, w2_phi, [numel(spl.coefs) , 1]);
   tmp2 = accumarray(ixs, w2, [numel(spl.coefs) , 1]);
   
   tmp2(tmp2==0) = 1; % avoid division by zero of type 0/0
   
   correction = tmp1./tmp2;
   
   spl.coefs = spl.coefs + reshape(correction, size(spl.coefs));
   
end

function ixs = setup_cp_indices(ij, shape)
   
   offset = [repmat((0:3)', 4, 1),  reshape(repmat(0:3, 4, 1), [], 1)];

   offset = repmat(offset, size(ij,1), 1);
   
   ixs = reshape((repmat(ij', 16, 1)), 2, [])' + offset;
   
   ixs = sub2ind(shape, ixs(:,1), ixs(:,2));
   
end


function w = compute_weights(t)
   t2 = t.^2;
   t3 = t2 .* t;
   w = [1-t3, (3*t3 - 6 * t2 + 4), (-3*t3 + 3*t2 + 3*t + 1), t3] / 6;
   
end

function kvec = uniform_kvec(range, num_intervals)
   
   delta = diff(range) / num_intervals;
   intervals = repmat(delta, 1, num_intervals + 6);
   kvec = cumsum([range(1)-3*delta, intervals]);
   
end

function spl = swap_params(spl)

   spl.coefs = spl.coefs';
   
   [spl.knots_u, spl.knots_v] = deal(spl.knots_v, spl.knots_u);
   [spl.orders(1), spl.orders(2)] = deal(spl.orders(2), spl.orders(1));
   
end

function spl = refine(spl)
   spl = refine_one(spl, 1);
   spl = refine_one(spl, 2);
end

function spl = refine_one(spl, dir)  % 'dir' should be 0 ('u') or 1 ('v')
   
   if dir == 1
      spl = swap_params(spl);
   end
   
   % refine u-knotvector
   range = [spl.knots_u(4), spl.knots_u(end-3)];
   intervals = numel(spl.knots_u) - 7;
   spl.knots_u = uniform_kvec(range, 2*intervals);
   
   % refine spline coefficients
   n = size(spl.coefs, 1);
   
   M1 = spdiags(0.5 * ones(n, 2), [0, 1], n-1, n);
   M2 = spdiags(1/8 * repmat([1,6,1], n, 1), [0, 1, 2], n-2, n);
   
   M = zeros(2*n-3, n);
   M(1:2:end, :) = M1;
   M(2:2:end, :) = M2;
   spl.coefs = M * spl.coefs;
   
   % swap back if necessary
   if dir == 1
      spl = swap_params(spl);
   end
end
